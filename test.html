<!DOCTYPE html>
<html lang="en">

	<head>
		<meta charset="UTF-8" />
		<meta http-equiv="X-UA-Compatible" content="IE=edge" />
		<meta name="viewport"
			content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no" />
		<title>Space Warrior</title>

		<script src="lib/vue.js"></script>
		<style>
			body {
				font-family: 'Quicksand', 'NowarRounded';
				background-color: #fff3
			}


			@media (prefers-color-scheme: dark) {
				body {
					background-color: #2222
				}
			}

			canvas {
				display: block;
			}

			::-webkit-scrollbar {
				display: none;
			}

			.jsoneditor {
				border: none !important;
			}

			.jse-absolute-popup {
				transform: scale(0.75);
				transform-origin: 100% 100%;
			}

			.jse-sort {
				display: none;
			}

			.jse-transform {
				display: none;
			}

			.jse-powered-by {
				display: none;
			}

			@media screen and (min-width: 800px) {
				body {
					--side-bar-width: 313px;
				}
			}

			@media screen and (max-width: 799px) {
				body {
					--side-bar-width: 39.125vw;
				}
			}

			/* 模态窗口基础样式 */
			.modal {
				display: block;
				/* 默认隐藏 */
				position: fixed;
				left: 0;
				top: 0;
				width: 100%;
				height: 100%;
				background-color: rgba(0, 0, 0, 0.5);
				/* 半透明遮罩层 */
				z-index: 1000;
				/* 确保在最上层 */
			}

			/* 模态内容样式 */
			.modal-content {
				background-color: #fefefe;
				margin: 10% auto;
				padding: 20px;
				border: 1px solid #888;
				width: 80%;
			}

			/* 关闭按钮样式 */
			.close {
				color: #aaa;
				float: right;
				font-size: 28px;
				font-weight: bold;
			}

			.close:hover,
			.close:focus {
				color: black;
				text-decoration: none;
				cursor: pointer;
			}

			.btn_blue {
				background-color: dodgerblue;
				color: white;
				border: 0;
				font-size: 16px;
				border-radius: 5px;
				font-weight: bold;
				border: solid 1px #0055ff;
			}

			.btn_yellow {
				background-color: #00ff00;
				color: white;
				border: 0;
				font-size: 16px;
				border-radius: 5px;
				font-weight: bold;
				border: solid 1px #00aa00;
			}

			/* .jse-search{display: none;} */
		</style>
	</head>

	<body style="">
		<script type="importmap">
			{
						"imports": {
							"three": "./lib/three/build/three.module.js",
							"three/addons/": "./lib/three/examples/jsm/",
							"taskVision":"./lib/task_vision.js"
						}
					}
				</script>

		<div id="vue-target">

			<div id="model" style="
                    top: 0;
                    left: 0;
                    width: calc(100vw - var(--side-bar-width));
                    height: 100vh;
                    background-color: #fff0;
                "></div>

		</div>

		<script type="module">
			import * as THREE from 'three';
			import {
				OrbitControls
			} from 'three/addons/controls/OrbitControls.js';
			const vertexShader = `
			void main() {
			    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
			}
			`;

			const fragmentShader = `
			uniform float iTime;
			uniform vec2 iResolution;
			int iterations=17;
			float formuparam=0.53;
			
			int volsteps= 20;
			float stepsize= 0.1;
			
			float zoom=   0.800;
			float tile=   0.850;
			float speed=  0.0010 ;
			
			float brightness= 0.0015;
			float darkmatter= 0.300;
			float distfading= 0.730;
			float saturation= 0.850;
			
			void main() {
					vec2 uv=gl_FragCoord.xy/iResolution.xy-.5;
					uv.y*=iResolution.y/iResolution.x;
					vec3 dir=vec3(uv*zoom,1.);
					float time=iTime*speed+.25;
				
			
					float a1=.5+100.0/iResolution.x*2.;
					float a2=.8+100.0/iResolution.y*2.;
					mat2 rot1=mat2(cos(a1),sin(a1),-sin(a1),cos(a1));
					mat2 rot2=mat2(cos(a2),sin(a2),-sin(a2),cos(a2));
					dir.xz*=rot1;
					dir.xy*=rot2;
					vec3 from=vec3(1.,.5,0.5);
					from+=vec3(time*2.,time,-2.);
					from.xz*=rot1;
					from.xy*=rot2;
					
					//volumetric rendering
					float s=0.1,fade=1.;
					vec3 v=vec3(0.);
					for (int r=0; r<volsteps; r++) {
						vec3 p=from+s*dir*.5;
						p = abs(vec3(tile)-mod(p,vec3(tile*2.)));
						float pa,a=pa=0.;
						for (int i=0; i<iterations; i++) { 
							p=abs(p)/dot(p,p)-formuparam; 
							a+=abs(length(p)-pa); 
							pa=length(p);
						}
						float dm=max(0.,darkmatter-a*a*.001);
						a*=a*a; 
						if (r>6) fade*=1.-dm;
						v+=fade;
						v+=vec3(s,s*s,s*s*s*s)*a*brightness*fade; 
						fade*=distfading;
						s+=stepsize;
					}
					v=mix(vec3(length(v)),v,saturation);
					gl_FragColor = vec4(v*.01,1.);
			}
			`;
			
			const scene = new THREE.Scene();
			const renderer = new THREE.WebGLRenderer({
				antialias: true
			});
			renderer.setPixelRatio(window.devicePixelRatio);
			renderer.setSize(
				document.querySelector("#model").clientWidth,
				document.querySelector("#model").clientHeight
			);
			renderer.shadowMap.enabled = true;

			renderer.shadowMap.type = THREE.PCFSoftShadowMap;

			//renderer.autoClear = false;
			renderer.outputEncoding = THREE.sRGBEncoding; // 输出编码
			//ReinhardToneMapping
			renderer.toneMapping = THREE.ACESFilmicToneMapping; // 色调映射
			renderer.toneMappingExposure = 0.9; // 色调映射曝光
			renderer.setPixelRatio(window.devicePixelRatio);
			//renderer.setClearColor(0x000000, 1); //设置背景颜色
			document.querySelector("#model").appendChild(renderer.domElement);
			
			const camera = new THREE.PerspectiveCamera(
				50,
				document.querySelector("#model").clientWidth /
				document.querySelector("#model").clientHeight,
				1,
				5000.0
			);
			camera.position.set(0, 0, 0);
			camera.lookAt(0, 10, 0);
			
			const uniforms = {
				iTime: {
					value: 0
				},
				iResolution: {
					value: new THREE.Vector2(window.innerWidth, window.innerHeight)
				}
			};
			const shaderMaterial = new THREE.ShaderMaterial({
				uniforms: uniforms,
				vertexShader: vertexShader,
				fragmentShader: fragmentShader,
			});
			
			const geometry = new THREE.SphereGeometry(50, 50,50);
			//geometry.scale(-1,1,1);
			const mesh = new THREE.Mesh(geometry, shaderMaterial);
			mesh.position.set(0, 0, 0);
			mesh.rotation.y = -Math.PI;
			scene.add(mesh);
			
			const controls = new OrbitControls(
				camera,
				renderer.domElement
			);
			controls.screenSpacePanning = true;
			controls.target.set(0.0, 1.0, 0.0);
			controls.update();
			
			
			
			animate();

			window.addEventListener(
				"resize",
				function() {
					camera.aspect =
						document.querySelector("#model").clientWidth /
						document.querySelector("#model").clientHeight;
					camera.updateProjectionMatrix();
					renderer.setSize(
						document.querySelector("#model").clientWidth,
						document.querySelector("#model").clientHeight
					);
				},
				false
			);

			function animate() {
				uniforms.iTime.value += 0.05;
				renderer.render(scene, camera);
				requestAnimationFrame(animate);
			}
		</script>
	</body>

</html>